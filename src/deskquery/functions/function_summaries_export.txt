def analyze_utilization(
    data: Dataset,
    include_fixed: bool = False,
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[str] = None,
    room_name: Optional[str] = None,
    
    weekday: Optional[List[str]] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,

    threshold: Optional[float] = None,
    count_below: bool = False,
) -> dict[str, object]:
Computes statistical measures of workspace utilization over time, grouped by desk, room, or weekday.

Utilization is calculated by dividing the number of actual bookings by the number of possible bookings 
per group (based on date range, included weekdays, and number of desks). Daily booking counts are used 
to compute variability (min, max, variance) per group key.

Args:
    data (Dataset): The dataset containing all bookings.
    include_fixed (bool): If True, expands recurring bookings across valid weekdays.
    by_desks (bool): If True, groups statistics by desk (e.g., 'Room_3').
    by_room (bool): If True, groups statistics by room.
    by_day (bool): If True, groups statistics by weekday (e.g., 'Monday').
    desk_id (Optional[List[int]]): If provided, filters the analysis to the selected desk IDs.
    room_name (Optional[List[str]]): If provided, filters the analysis to the selected rooms.
    weekday (List[str]): List of weekday names (e.g., ['monday', 'friday']) to include. Defaults to weekdays (Mon–Fri).
    start_date (Optional[datetime]): Start of the evaluation period. Defaults to 90 days ago.
    end_date (Optional[datetime]): End of the evaluation period. Defaults to today.

Returns:
    dict: A structured result containing:
        - "data": dict[str, dict[str, float]]
            Mapping from group key to:
            {
                "mean": Average utilization over time,
                "min": Lowest daily utilization,
                "max": Highest daily utilization,
                "var": Variance of daily utilization
            }
        - "error": int
            0 if successful
        - "error_msg": str
            Empty string if no error
        - "plotable": int
            Placeholder for visualization integration (always 0)

Raises:
    ValueError: If none or more than one of `by_desks`, `by_room`, or `by_day` is set to True.

Example:
    >>> utilization_stats(data, by_room=True, include_fixed=True)
    {
        "data": {
            "Room A": {"mean": 0.63, "min": 0.4, "max": 0.9, "var": 0.02},
            "Room B": {"mean": 0.12, "min": 0.0, "max": 0.3, "var": 0.01}
        },
        "error": 0,
        "error_msg": "",
        "plotable": 0
    }

-

def utilization_stats(
    data: Dataset,
    include_fixed: bool = False,
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> dict[str, object]:
Identifies utilization outliers based on deviation from the global mean.

This function detects keys (desks, rooms, or weekdays) whose average utilization deviates significantly 
from the global mean (by at least the given threshold). It uses the same aggregation logic as 
`analyze_utilization` and returns only the outlier entries.

Args:
    data (Dataset): The dataset containing booking data.
    include_fixed (bool): If True, expands recurring bookings into daily entries.
    threshold (float): Minimum absolute deviation from the mean to classify as anomalous.
    by_desks (bool): If True, detects anomalies per desk.
    by_room (bool): If True, detects anomalies per room.
    by_day (bool): If True, detects anomalies per weekday.
    desk_id (Optional[List[int]]): Optional desk filter.
    room_name (Optional[List[str]]): Optional room filter.
    weekday (List[str]): List of weekdays to consider in the analysis.
    start_date (Optional[datetime]): Start of the analysis window. Defaults to 90 days ago.
    end_date (Optional[datetime]): End of the analysis window. Defaults to today.

Returns:
    dict: A dictionary containing:
        - "data": dict[str, float]
            Keys with anomalous utilization values (deviation ≥ threshold).
        - "count": int
            Number of detected anomalies.
        - "error": int
            0 if successful.
        - "error_msg": str
            Empty if no error.
        - "plotable": bool
            Always True (can be visualized directly)

Raises:
    ValueError: If none or more than one of `by_desks`, `by_room`, or `by_day` is set to True.

Example:
    >>> detect_utilization_anomalies(data, by_day=True, threshold=0.1)
    {
        "data": {
            "Monday": 0.71,
            "Friday": 0.39
        },
        "count": 2,
        "error": 0,
        "error_msg": "",
        "plotable": True
    }

-

def detect_utilization_anomalies(
    data: Dataset,
    include_fixed: bool = False,
    
    threshold: float = 0.2, 
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> dict[str, object]:
Detects rooms or weekdays with anomalously high or low utilization values.

Args:
    data (Dataset): Booking dataset.
    threshold (float): Minimum absolute deviation from the global mean utilization.
    by_room (bool): If True, analyze by room. If False, analyze by weekday.
    include_fixed (bool): Whether to include expanded fixed bookings.
    start_date (datetime, optional): Start date for analysis.
    end_date (datetime, optional): End date for analysis.

Returns:
    dict: Structure:
        {
            "data": {key: utilization_value},
            "count": int,
            "error": 0,
            "error_msg": str,
            "plotable": True
        }

-

def simulate_policy(
    policy_type: str, 
    mandatory_day: Optional[str] = None, 
    min_days_per_week: Optional[int] = None, 
    employee_count: Optional[int] = None, 
    simulation_weeks: int = 4
) -> None:
Simulates the impact of a given policy on desk utilization.

Args:
    policy_type: Type of policy, e.g., 'mandatory_day', 'min_days_per_week'.
    mandatory_day: Specific weekday to enforce attendance on (if applicable).
    min_days_per_week: Minimum number of days employees must attend in a week.
    employee_count: Number of employees. Defaults to current count.
    simulation_weeks: Number of weeks to run the simulation.

Returns:

-

def detect_policy_violations(
    policy_type: str, 
    min_days_per_week: Optional[int] = None, 
    mandatory_day: Optional[str] = None, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Identifies employees who do not comply with a given policy.

Args:
    policy_type: The policy being evaluated.
    min_days_per_week: Required minimum days per week for attendance.
    mandatory_day: Required attendance day if applicable.
    weekdays: Days of the week considered.
    start_date: Start of the period to evaluate.
    end_date: End of the period to evaluate.

Returns:

-

def suggest_balanced_utilization_policy(
    target_utilization: float, 
    max_mandatory_days: int = 2
) -> None:
Suggests an attendance policy to achieve a more balanced desk utilization.

This function analyzes historical booking patterns and simulates different attendance 
strategies to recommend a policy that helps distribute occupancy more evenly 
across weekdays and rooms.

Args:
    target_utilization: Desired average utilization rate per weekday, 
        expressed as a float between 0 and 1 (e.g., 0.75 for 75%).
    max_mandatory_days: Maximum number of mandatory office days per week 
        that should be imposed by the suggested policy. 
        This parameter limits how strict the policy recommendation can be.

Returns:
   
Notes:
    The function may store or output the suggestion elsewhere (e.g., in a report, log, or user interface).

-

def get_booking_repeat_pattern(
    dataset: Dataset,
    most_used_desk: int = 1, # TO DO: Still needs to be implemented 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None,
    include_fixed: bool = True,
) -> FunctionRegistryExpectedFormat:
Identifies users who book the same desks or same days repeatedly.

Args:
    most_used_desk: If several tables are booked, specifies how many tables should be issued
    weekdays: Days of interest.
    start_date: Start date.
    end_date: End date.

Returns:

-

def get_booking_clusters(
    dataset: Dataset,
    distance_threshold: float = 3, 
    co_booking_count_min: int = 3, 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Finds booking clusters, i.e., groups of users who often book nearby desks.

Args:
    distance_threshold: Spatial proximity to define a cluster.
    co_booking_count_min: Minimum times users must co-book nearby desks.
    weekdays: Days to consider.
    start_date: Start date.
    end_date: End date.

Returns:

-

def get_co_booking_frequencies(
    dataset: Dataset,
    min_shared_days: int, 
    same_room_only: bool, 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
)-> None:
Detects employee pairs who frequently book on the same days.

Args:
    min_shared_days: Minimum number of shared booking days.
    same_room_only: If True, limits to co-bookings in the same room.
    weekdays: Days to analyze.
    start_date: Start date.
    end_date: End date.

Returns:

-

def generate_heatmap(
    by_room: bool, 
    resolution: str, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
ö
Generates a heatmap showing desk bookings over time.

Args:
    by_room: If True, shows heatmap per room.
    resolution: Time resolution of heatmap: 'daily', 'weekly', or 'monthly'.
    weekdays: Days of the week to include.
    start_date: Start date for data.
    end_date: End date for data.

Returns:

-

def generate_plot_interactive(
    by_room: bool, 
    resolution: str, weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Produces an interactive plot of desk booking data.

Args:
    by_room: If True, plots are grouped by room.
    resolution: Level of temporal detail ('daily', 'weekly', etc.).
    weekdays: Days of interest.
    start_date: Analysis start date.
    end_date: Analysis end date.

Returns:

-

def generate_plot(
    by_room: bool, 
    resolution: str, 
    desk: int, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Creates a plot of desk utilization over time.

Args:
    by_room: If True, groups data by room.
    resolution: Time granularity.
    desk: Desk ID or 'all' to include all desks.
    weekdays: Relevant weekdays.
    start_date: Starting date.
    end_date: Ending date.

Returns:

-

def estimate_table_needs(
    target_utilization: float, 
    attendance_days: int, 
    employee_count: int, 
    existing_desks: Optional[int] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Estimates required number of desks to meet a target utilization.

Args:
    target_utilization: Target average utilization.
    attendance_days: Number of days employees are expected to attend weekly.
    employee_count: Total number of employees considered.
    existing_desks: Number of currently available desks.
    data_for_forcast_start_date: Date to start using historical data.
    data_for_forcast_end_date: Date to end using historical data.

Returns:

-

def forecast_desk_demand(
    current_employee_count: int, 
    weekly_growth_rate: float,
    available_desks: int, 
    target_utilization: float, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Forecasts desk demand based on employee growth.

Args:
    current_employee_count: Current number of employees.
    weekly_growth_rate: Weekly employee growth as a percentage.
    available_desks: Total number of desks available.
    target_utilization: Desired desk utilization threshold.
    data_for_forcast_start_date: Historical data start.
    data_for_forcast_end_date: Historical data end.

Returns:

-

def simulate_room_closure(
    room_id: str, 
    reassign_strategy: str, 
    time_closed: Optional[str] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Simulates what happens if a room is closed.

Args:
    room_id: Identifier of the room to close.
    reassign_strategy: Strategy to reassign affected bookings (e.g., 'random').
    time_closed: Timeframe of the closure.
    data_for_forcast_start_date: Data window start.
    data_for_forcast_end_date: Data window end.

Returns:

-

def estimate_max_employees_per_room(
    room_id: str, 
    target_utilization: float, 
    average_attendance_days: int
) -> None:
Estimates maximum employees for a room given a target utilization.

Args:
    room_id: Identifier for the room.
    target_utilization: Desired utilization rate.
    average_attendance_days: Expected days in office per week.

Returns:
    None. Useful for space planning.

-

