def mean_utilization(
    data: Dataset,
    include_fixed: bool = False,
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: Optional[List[str]] = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
    start_date: Optional[datetime.datetime] = None,
    end_date: Optional[datetime.datetime] = None,
    threshold: Optional[float] = None,
    top_or_bottom_n: Optional[int] = None,
    from_bottom: Optional[bool] = False,
) -> FunctionRegistryExpectedFormat:
Computes mean utilization of workspace utilization over a given timeframe, grouped by either desk, room, or weekday.
Should only be used to group by one of those attributes.

Utilization is defined as the number of actual bookings divided by the number of possible bookings per group.
The possible bookings depend on the time window, included weekdays, selected desk_ids or selected room_names.

Optionally, the result can be filtered by a threshold or by selecting only the top or bottom N utilization values by 
providing a threshold and selecting with from_bottom = True all entities where utilization <= threshold or with
False utilization >= threshold. The same goes with the top_or_bottom_n where from_bottom = False means the top N
utilizations and with from_bottom = True the bottom N utilizations.

---

def utilization_stats(
    data: Dataset,
    include_fixed: bool = False,
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    start_date: Optional[datetime.datetime] = None,
    end_date: Optional[datetime.datetime] = None,
) -> FunctionRegistryExpectedFormat:
Identifies utilization outliers based on deviation from the global mean.

This function detects keys (desks, rooms, or weekdays) whose average utilization deviates significantly 
from the global mean (by at least the given threshold). It uses the same aggregation logic as 
`analyze_utilization` and returns only the outlier entries.

---

def detect_utilization_anomalies(
    data: Dataset,
    include_fixed: bool = False,
    threshold: float = 0.2,
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    start_date: Optional[datetime.datetime] = None,
    end_date: Optional[datetime.datetime] = None,
) -> FunctionRegistryExpectedFormat:
Detects desks, rooms or weekdays with abnormally high or low mean utilization values.

---

def simulate_policy(
    data: Dataset,
    policy: Dict,
    exceptions: Optional[Dict[int, Dict]] = None,
    random_assignments: Optional[List[Tuple[int, Dict]]] = None,
    num_weeks: Optional[int] = 100,
    weekdays: Optional[List[str]] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    plotable: bool = True
) -> FunctionRegistryExpectedFormat:
Assigns policies and simulates the weekly attendance of all employees based on them. A policy is a dict of the following parameters 
which are included in the policy, exceptions (if given) and random_assignments (if given):

policy = {
    timeframe (str): Policy timeframe (currently only "week" is supported);
    fixed_days (Optional[List[str]]): Days that are always selected;
    choseable_days (Optional[List[str]]): Days from which a fixed number is chosen;
    number_choseable_days (Optional[int]): Number of days to pick from `choseable_days`;
    number_days (Optional[int]): Target total number of days;
    more_days_allowed (bool): If True, adds additional days based on attendance.
}

---

def detect_policy_violations(
    data: Dataset,
    policy: Dict,
    exceptions: Optional[Dict[int, Dict]] = None,
    random_assignments: Optional[List[Tuple[int, Dict]]] = None,
    weekdays: Optional[List[str]] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    start_date: Optional[datetime.datetime] = None, 
    end_date: Optional[datetime.datetime] = None,
    only_stats: Optional[bool] = False
) -> FunctionRegistryExpectedFormat:
Takes a policy and searches the data for violations. A policy is a dict of the following parameters 
which are included in the policy, exceptions (if given) and random_assignments (if given):

policy = {
    timeframe (str): Policy timeframe (currently only "week" is supported);
    fixed_days (List[str], optional): Days that are always selected;
    choseable_days (List[str], optional): Days from which a fixed number is chosen;
    number_choseable_days (int, optional): Number of days to pick from `choseable_days`;
    number_days (int, optional): Target total number of days;
    more_days_allowed (bool): If True, adds additional days based on attendance.
}

---

def get_booking_repeat_pattern(
    data: Dataset,
    user_names: Optional[str | Sequence[str]] = None,
    user_ids: Optional[int | Sequence[int]] = None,
    most_used_desk: int = 1,
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime.datetime] = None, 
    end_date: Optional[datetime.datetime] = None,
    include_fixed: bool = True,
) -> FunctionRegistryExpectedFormat:
Identifies users who book the same desks or same days repeatedly.

---

def get_booking_clusters(
    data: Dataset,
    co_booking_count_min: int = 3, 
    user_ids: Optional[list[int]] = None,
    include_fixed: bool = False,
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime.datetime] = None, 
    end_date: Optional[datetime.datetime] = None,
) -> FunctionRegistryExpectedFormat:
Finds groups of users who frequently book desks close to each other.
Filters data by users, dates, and weekdays, then identifies clusters based 
on a minimum number of shared bookings.

---

def get_co_booking_frequencies(
    data: Dataset,
    min_shared_days: int = 5, 
    same_room_only: Optional[bool] = None, 
    include_fixed: bool = True,
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime.datetime] = None, 
    end_date: Optional[datetime.datetime] = None,
)-> FunctionRegistryExpectedFormat:
Identifies pairs of users who frequently book on the same days and calculates co-booking statistics.

This function analyzes booking behavior over a specified timeframe and set of weekdays,
identifying user pairs who have booked on the same day at least `min_shared_days` times.
Optionally, it can restrict analysis to bookings in the same room.

---

def forecast_employees(
    data: Dataset,
    lag: Optional[int] = 90,
    booking_type: Optional[str] = "all",
    weekly_growth_rate: Optional[float] = None,
    weekly_absolute_growth: Optional[float] = None,
    forecast_model: Optional[str] = "linear",
    weeks_ahead: Optional[int] = 52,
    plotable: bool = True
) -> FunctionRegistryExpectedFormat:
Forecasts the number of employees with different models such as linear or sarima. 
Furthermore, this function can handle fixed weekly growth rates and fixed weekly absolute growth. 
It gets the worker time series and then forecasts future employee numbers.

---

def estimate_necessary_desks(
    data: Dataset,
    policy: Optional[Dict] = None,
    exceptions: Optional[Dict[int, Dict]] = None,
    random_assignments: Optional[List[Tuple[int, Dict]]] = None,
    lag: Optional[int] = 90,
    booking_type: Optional[str] = "all",
    weekly_growth_rate: Optional[float] = None,
    weekly_absolute_growth: Optional[float] = None,
    forecast_model: Optional[str] = "linear",
    weeks_ahead: Optional[int] = 52,
    target_utilization: Optional[float] = 1.0,
) -> FunctionRegistryExpectedFormat:
Estimates required number of desks to meet a target utilization. It can handle policies. 
If no policy is given, it uses the attendance profile and a standard policy (no requirements).
Either time series forecast is used or the weekly growth rate / absolute growth.
A policy is a dict of the following parameters which are included in the policy, 
exceptions (if given) and random_assignments (if given):

policy = {
    timeframe (str): Policy timeframe (currently only "week" is supported);
    fixed_days (List[str], optional): Days that are always selected;
    choseable_days (List[str], optional): Days from which a fixed number is chosen;
    number_choseable_days (int, optional): Number of days to pick from `choseable_days`;
    number_days (int, optional): Target total number of days;
    more_days_allowed (bool): If True, adds additional days based on attendance;
}

---

