def analyze_utilization(
    data: Dataset,
    include_fixed: bool = False,
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    
    weekday: Optional[List[str]] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    threshold: Optional[float] = None,
    count_below: bool = False,
) -> dict[str, object]:
Computes statistical measures of workspace utilization over time, grouped by desk, room, or weekday.

Utilization is calculated by dividing the number of actual bookings by the number of possible bookings 
per group (based on date range, included weekdays, and number of desks). Daily booking counts are used 
to compute variability (min, max, variance) per group key.

---

def utilization_stats(
    data: Dataset,
    include_fixed: bool = False,
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> dict[str, object]:
Identifies utilization outliers based on deviation from the global mean.

This function detects keys (desks, rooms, or weekdays) whose average utilization deviates significantly 
from the global mean (by at least the given threshold). It uses the same aggregation logic as 
`analyze_utilization` and returns only the outlier entries.

---

def detect_utilization_anomalies(
    data: Dataset,
    include_fixed: bool = False,
    
    threshold: float = 0.2, 
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> dict[str, object]:
Detects rooms or weekdays with anomalously high or low utilization values.

---

def simulate_policy(
    policy_type: str, 
    mandatory_day: Optional[str] = None, 
    min_days_per_week: Optional[int] = None, 
    employee_count: Optional[int] = None, 
    simulation_weeks: int = 4
) -> None:
Simulates the impact of a given policy on desk utilization.

---

def detect_policy_violations(
    policy_type: str, 
    min_days_per_week: Optional[int] = None, 
    mandatory_day: Optional[str] = None, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Identifies employees who do not comply with a given policy.

---

def suggest_balanced_utilization_policy(
    target_utilization: float, 
    max_mandatory_days: int = 2
) -> None:
Suggests an attendance policy to achieve a more balanced desk utilization.

This function analyzes historical booking patterns and simulates different attendance 
strategies to recommend a policy that helps distribute occupancy more evenly 
across weekdays and rooms.

---

def get_booking_repeat_pattern(
    dataset: Dataset,
    most_used_desk: int = 1, # TO DO: Still needs to be implemented 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None,
    include_fixed: bool = True,
) -> FunctionRegistryExpectedFormat:
Identifies users who book the same desks or same days repeatedly.

---

def get_booking_clusters(
    dataset: Dataset,
    distance_threshold: float = 3, 
    co_booking_count_min: int = 3, 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Finds booking clusters, i.e., groups of users who often book nearby desks.

---

def get_co_booking_frequencies(
    dataset: Dataset,
    min_shared_days: int, 
    same_room_only: bool, 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
)-> None:
Detects employee pairs who frequently book on the same days.

---

def generate_heatmap(
    by_room: bool, 
    resolution: str, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
ö
Generates a heatmap showing desk bookings over time.

---

def generate_plot_interactive(
    by_room: bool, 
    resolution: str, weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Produces an interactive plot of desk booking data.

---

def generate_plot(
    by_room: bool, 
    resolution: str, 
    desk: int, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Creates a plot of desk utilization over time.

---

def estimate_table_needs(
    target_utilization: float, 
    attendance_days: int, 
    employee_count: int, 
    existing_desks: Optional[int] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Estimates required number of desks to meet a target utilization.

---

def forecast_desk_demand(
    current_employee_count: int, 
    weekly_growth_rate: float,
    available_desks: int, 
    target_utilization: float, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Forecasts desk demand based on employee growth.

---

def simulate_room_closure(
    room_id: str, 
    reassign_strategy: str, 
    time_closed: Optional[str] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Simulates what happens if a room is closed.

---

def estimate_max_employees_per_room(
    room_id: str, 
    target_utilization: float, 
    average_attendance_days: int
) -> None:
Estimates maximum employees for a room given a target utilization.

---

