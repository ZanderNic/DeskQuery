def mean_utilization(
    data: Dataset,
    include_fixed: bool = False,
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[str]] = None,
    room_name: Optional[List[str]] = None,
    weekday: Optional[List[str]] = None,
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    threshold: Optional[float] = None,
    top_or_bottom_n: Optional[int] = None,
    from_bottom: Optional[bool] = False,
) -> dict[str, object]:
Computes mean utilization of workspace utilization over a given timeframe, grouped by either desk, room, or weekday. Should 
only be used to group by one of those attributes.

Utilization is defined as the number of actual bookings divided by the number of possible bookings per group.
The possible bookings depend on the time window, included weekdays, selected desk_ids or selected room_names.

Optionally, the result can be filtered by a threshold or by selecting only the top or bottom N utilization values by 
providing a threshold and selecting with from_bottom = True all entities where utilization <= threshold or with False 
utilization >= threshold. The same goes with the top_or_bottom_n where from_bottom = False means the top N utilizations
and with from_bottom = True the bottom N utilizations.

---

def utilization_stats(
    data: Dataset,
    include_fixed: bool = False,
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> dict[str, object]:
Identifies utilization outliers based on deviation from the global mean.

This function detects keys (desks, rooms, or weekdays) whose average utilization deviates significantly 
from the global mean (by at least the given threshold). It uses the same aggregation logic as 
`analyze_utilization` and returns only the outlier entries.

---

def detect_utilization_anomalies(
    data: Dataset,
    include_fixed: bool = False,
    
    threshold: float = 0.2, 
    
    by_desks: bool = False,
    by_room: bool = False,
    by_day: bool = False,
    
    desk_id: Optional[List[int]] = None,
    room_name: Optional[List[str]] = None,
    weekday: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"],
    
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
) -> dict[str, object]:
Detects rooms or weekdays with anomalously high or low utilization values.

---

def simulate_policy(
    policy_type: str, 
    mandatory_day: Optional[str] = None, 
    min_days_per_week: Optional[int] = None, 
    employee_count: Optional[int] = None, 
    simulation_weeks: int = 4
) -> None:
Simulates the impact of a given policy on desk utilization.

---

def detect_policy_violations(
    policy_type: str, 
    min_days_per_week: Optional[int] = None, 
    mandatory_day: Optional[str] = None, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Identifies employees who do not comply with a given policy.

---

def suggest_balanced_utilization_policy(
    target_utilization: float, 
    max_mandatory_days: int = 2
) -> None:
Suggests an attendance policy to achieve a more balanced desk utilization.

This function analyzes historical booking patterns and simulates different attendance 
strategies to recommend a policy that helps distribute occupancy more evenly 
across weekdays and rooms.

---

def get_booking_repeat_pattern(
    dataset: Dataset,
    most_used_desk: int = 1, # TODO: Still needs to be implemented 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None,
    include_fixed: bool = True,
) -> FunctionRegistryExpectedFormat:
Identifies users who book the same desks or same days repeatedly.

---

def get_booking_clusters(
    dataset: Dataset,
    distance_threshold: float = 3, 
    co_booking_count_min: int = 3, 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Finds booking clusters, i.e., groups of users who often book nearby desks.

---

def get_co_booking_frequencies(
    dataset: Dataset,
    min_shared_days: int, 
    same_room_only: bool, 
    weekdays: List[str] = ["monday", "tuesday", "wednesday", "thursday", "friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
)-> None:
Detects employee pairs who frequently book on the same days.

---

def estimate_table_needs(
    target_utilization: float, 
    attendance_days: int, 
    employee_count: int, 
    existing_desks: Optional[int] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Estimates required number of desks to meet a target utilization.

---

def forecast_desk_demand(
    current_employee_count: int, 
    weekly_growth_rate: float,
    available_desks: int, 
    target_utilization: float, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Forecasts desk demand based on employee growth.

---

def simulate_room_closure(
    room_id: str, 
    reassign_strategy: str, 
    time_closed: Optional[str] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Simulates what happens if a room is closed.

---

def estimate_max_employees_per_room(
    room_id: str, 
    target_utilization: float, 
    average_attendance_days: int
) -> None:
Estimates maximum employees for a room given a target utilization.

---

