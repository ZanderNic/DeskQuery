def get_utilization(
        overall: bool = False, 
        by_room: bool = False, 
        room: Optional[str] = None, 
        weekday: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
        start_date: Optional[datetime] = None, 
        end_date: Optional[datetime] = None
) -> None:
Returns desk utilization based on provided filters.

Args:
    overall: If True, returns overall utilization across all desks.
    by_room: If True, returns utilization per room.
    room: Specific room to filter utilization for. If None, includes all rooms.
    weekday: List of weekdays to consider in the analysis.
    start_date: Start of the period to analyze. If None, uses current date.
    end_date: End of the period to analyze. If None, uses current date.

Returns:
    The average utilization of the deks filltered by the filter

-

def get_over_under_utilized_desks(
    threshold: float, 
    by_room: Optional[bool] = None, 
    under: bool = False, 
    weekday: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Returns desks with usage above or below a specified utilization threshold.

Args:
    threshold: Utilization threshold as a float (e.g., 0.8 for 80%).
    by_room: If True, aggregates results per room. If None, shows per-desk.
    under: If True, returns desks with utilization below the threshold if false will return desks with utilization above threshold.
    weekday: Weekdays to include in the evaluation.
    start_date: Beginning of the time window. If None, defaults to ###TODO.
    end_date: End of the time window. If None, defaults to today.

Returns:
   

-

def get_daily_utilization_stats(
    by_room: bool = False, 
    by_desc: bool = False,
    weekday: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Returns average, minimum, maximum and variance utilization for each weekday.

Args:
    by_room: If True, computes stats separately per room.
    by_desc: If True, computes stats separately per desk.
    weekday: List of weekdays to include.
    start_date: Start of the evaluation period.
    end_date: End of the evaluation period.

Returns:
   

-

def get_days_above_bellow_threshold(
    threshold: float, 
    bellow: bool = False, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None 
)-> None:
Counts the number of days where utilization exceeds a given threshold.

Args:
    threshold: Utilization threshold as a float.
    bellow: If True, returns days with utilization below the threshold if false will return days with utilization above threshold.
    weekdays: Days of the week to analyze.
    start_date: Beginning of date range.
    end_date: End of date range.

Returns:
    

-

def detect_utilization_anomalies(
    threshold: float = 0.2, 
    by_room: bool = False, 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Detects days or rooms with significant utilization anomalies.

Args:
    threshold: Minimum deviation from average to be flagged.
    by_room: If True, checks per room.
    start_date: Period start.
    end_date: Period end.

Returns:

-

def simulate_policy(
    policy_type: str, 
    mandatory_day: Optional[str] = None, 
    min_days_per_week: Optional[int] = None, 
    employee_count: Optional[int] = None, 
    simulation_weeks: int = 4
) -> None:
Simulates the impact of a given policy on desk utilization.

Args:
    policy_type: Type of policy, e.g., 'mandatory_day', 'min_days_per_week'.
    mandatory_day: Specific weekday to enforce attendance on (if applicable).
    min_days_per_week: Minimum number of days employees must attend in a week.
    employee_count: Number of employees. Defaults to current count.
    simulation_weeks: Number of weeks to run the simulation.

Returns:

-

def detect_policy_violations(
    policy_type: str, 
    min_days_per_week: Optional[int] = None, 
    mandatory_day: Optional[str] = None, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Identifies employees who do not comply with a given policy.

Args:
    policy_type: The policy being evaluated.
    min_days_per_week: Required minimum days per week for attendance.
    mandatory_day: Required attendance day if applicable.
    weekdays: Days of the week considered.
    start_date: Start of the period to evaluate.
    end_date: End of the period to evaluate.

Returns:

-

def suggest_balanced_utilization_policy(
    target_utilization: float, 
    max_mandatory_days: int = 2
) -> None:
Suggests an attendance policy to achieve a more balanced desk utilization.

This function analyzes historical booking patterns and simulates different attendance 
strategies to recommend a policy that helps distribute occupancy more evenly 
across weekdays and rooms.

Args:
    target_utilization: Desired average utilization rate per weekday, 
        expressed as a float between 0 and 1 (e.g., 0.75 for 75%).
    max_mandatory_days: Maximum number of mandatory office days per week 
        that should be imposed by the suggested policy. 
        This parameter limits how strict the policy recommendation can be.

Returns:
   
Notes:
    The function may store or output the suggestion elsewhere (e.g., in a report, log, or user interface).

-

def get_avg_booking_per_employee(
    granularity: str = 'week', 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None,
    
) -> None:
Calculates the average number of bookings per employee.

Args:
    granularity: Period unit for average, e.g., 'week' or 'month'.
    weekdays: Days to include in the calculation.
    start_date: Start date of the analysis.
    end_date: End date of the analysis.

Returns:

-

def get_booking_repeat_pattern(
    min_repeat_count: int = 2, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Identifies users who book the same desks repeatedly.

Args:
    min_repeat_count: Minimum number of repeated bookings.
    weekdays: Days of interest.
    start_date: Start date.
    end_date: End date.

Returns:

-

def get_booking_clusters(
    distance_threshold: float = 3, 
    co_booking_count_min: int = 3, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Finds booking clusters, i.e., groups of users who often book nearby desks.

Args:
    distance_threshold: Spatial proximity to define a cluster.
    co_booking_count_min: Minimum times users must co-book nearby desks.
    weekdays: Days to consider.
    start_date: Start date.
    end_date: End date.

Returns:

-

def get_co_booking_frequencies(
    min_shared_days: int, 
    same_room_only: bool, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
)-> None:
Detects employee pairs who frequently book on the same days.

Args:
    min_shared_days: Minimum number of shared booking days.
    same_room_only: If True, limits to co-bookings in the same room.
    weekdays: Days to analyze.
    start_date: Start date.
    end_date: End date.

Returns:

-

def generate_heatmap(
    by_room: bool, 
    resolution: str, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
ö
Generates a heatmap showing desk bookings over time.

Args:
    by_room: If True, shows heatmap per room.
    resolution: Time resolution of heatmap: 'daily', 'weekly', or 'monthly'.
    weekdays: Days of the week to include.
    start_date: Start date for data.
    end_date: End date for data.

Returns:

-

def generate_plot_interactive(
    by_room: bool, 
    resolution: str, weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Produces an interactive plot of desk booking data.

Args:
    by_room: If True, plots are grouped by room.
    resolution: Level of temporal detail ('daily', 'weekly', etc.).
    weekdays: Days of interest.
    start_date: Analysis start date.
    end_date: Analysis end date.

Returns:

-

def generate_plot(
    by_room: bool, 
    resolution: str, 
    desk: int, 
    weekdays: List[str] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"], 
    start_date: Optional[datetime] = None, 
    end_date: Optional[datetime] = None
) -> None:
Creates a plot of desk utilization over time.

Args:
    by_room: If True, groups data by room.
    resolution: Time granularity.
    desk: Desk ID or 'all' to include all desks.
    weekdays: Relevant weekdays.
    start_date: Starting date.
    end_date: Ending date.

Returns:

-

def estimate_table_needs(
    target_utilization: float, 
    attendance_days: int, 
    employee_count: int, 
    existing_desks: Optional[int] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Estimates required number of desks to meet a target utilization.

Args:
    target_utilization: Target average utilization.
    attendance_days: Number of days employees are expected to attend weekly.
    employee_count: Total number of employees considered.
    existing_desks: Number of currently available desks.
    data_for_forcast_start_date: Date to start using historical data.
    data_for_forcast_end_date: Date to end using historical data.

Returns:

-

def forecast_desk_demand(
    current_employee_count: int, 
    weekly_growth_rate: float,
    available_desks: int, 
    target_utilization: float, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Forecasts desk demand based on employee growth.

Args:
    current_employee_count: Current number of employees.
    weekly_growth_rate: Weekly employee growth as a percentage.
    available_desks: Total number of desks available.
    target_utilization: Desired desk utilization threshold.
    data_for_forcast_start_date: Historical data start.
    data_for_forcast_end_date: Historical data end.

Returns:

-

def simulate_room_closure(
    room_id: str, 
    reassign_strategy: str, 
    time_closed: Optional[str] = None, 
    data_for_forcast_start_date: Optional[datetime] = None, 
    data_for_forcast_end_date: Optional[datetime] = None
) -> None:
Simulates what happens if a room is closed.

Args:
    room_id: Identifier of the room to close.
    reassign_strategy: Strategy to reassign affected bookings (e.g., 'random').
    time_closed: Timeframe of the closure.
    data_for_forcast_start_date: Data window start.
    data_for_forcast_end_date: Data window end.

Returns:

-

def estimate_max_employees_per_room(
    room_id: str, 
    target_utilization: float, 
    average_attendance_days: int
) -> None:
Estimates maximum employees for a room given a target utilization.

Args:
    room_id: Identifier for the room.
    target_utilization: Desired utilization rate.
    average_attendance_days: Expected days in office per week.

Returns:
    None. Useful for space planning.

-

